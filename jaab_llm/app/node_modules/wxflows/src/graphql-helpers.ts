// Copyright IBM Corp. 2024
// MIT License

// Copyright (c) 2018 Tim Qian

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

import {
  getNullableType,
  isEnumType,
  isInputObjectType,
  isInterfaceType,
  isListType,
  isNullableType,
  isObjectType,
  isScalarType,
  isUnionType,
  parse,
  print,
  type GraphQLArgument,
  type GraphQLField,
  type GraphQLSchema,
  type GraphQLType,
} from 'graphql'
import {RagVars} from './lib/rag'

/**
 * Compile arguments dictionary for a field
 * @param field current field object
 * @param duplicateArgCounts map for deduping argument name collisions
 * @param allArgsDict dictionary of all arguments
 */
export const getFieldArgsDict = (
  field: GraphQLField<any, any>,
  duplicateArgCounts: Record<string, number>,
  allArgsDict: Record<string, GraphQLArgument> = {},
): Record<string, GraphQLArgument> =>
  field.args.reduce(
    (o, arg) => {
      if (arg.name in duplicateArgCounts) {
        const index = duplicateArgCounts[arg.name] + 1
        duplicateArgCounts[arg.name] = index
        o[`${arg.name}${index}`] = arg
      } else if (allArgsDict[arg.name]) {
        duplicateArgCounts[arg.name] = 1
        o[`${arg.name}1`] = arg
      } else {
        o[arg.name] = arg
      }
      return o
    },
    {} as Record<string, GraphQLArgument>,
  )

/**
 * Generate variables string
 * @param dict dictionary of arguments
 */
export const getArgsToVarsStr = (dict: Record<string, GraphQLArgument>) =>
  Object.entries(dict)
    .map(([varName, arg]) => `${arg.name}: $${varName}`)
    .join(', ')

/**
 * Generate types string
 * @param dict dictionary of arguments
 */
export const getVarsToTypesStr = (dict: Record<string, GraphQLArgument>) =>
  Object.entries(dict)
    .map(([varName, arg]) => `$${varName}: ${arg.type}`)
    .join(', ')

/**
 * Generate a example value for a given a GraphQL type
 * @param type GraphQL type
 */
export const getSampleValueOfType = (type: GraphQLType): any => {
  if (isNullableType(type)) {
    return null
  }

  const nullableType = getNullableType(type)

  if (isScalarType(nullableType)) {
    const argType = nullableType.toString()
    switch (argType) {
      case 'Boolean':
        return true
      case 'Float':
        return 1.5
      case 'Int':
        return 1
      case 'Date':
      case 'DateTime':
      case 'Time':
        return new Date().toISOString()
      case 'JSON':
        return {foo: 'bar'}
      case 'Secret':
        return 'secret'
      case 'ID':
        return 'id'
      case 'String':
      default:
        return 'string'
    }
  }

  if (isEnumType(nullableType)) {
    const enumValues = nullableType.getValues()
    return enumValues.length ? enumValues[0].value : null
  }

  if (
    isObjectType(nullableType) ||
    isInterfaceType(nullableType) ||
    isInputObjectType(nullableType)
  ) {
    const fields = nullableType.getFields()
    return Object.fromEntries(
      Object.keys(fields)
        .map(fieldName => [
          fieldName,
          getSampleValueOfType(fields[fieldName].type),
        ])
        .filter(([_, value]) => value !== null),
    )
  }

  if (isListType(nullableType)) {
    const sampleListItem = getSampleValueOfType(nullableType.ofType)
    return [sampleListItem, sampleListItem]
  }
}

export const getSampleVars = (dict: Record<string, GraphQLArgument>) =>
  Object.fromEntries(
    Object.entries(dict).map(([varName, arg]) => [
      varName,
      arg.defaultValue || getSampleValueOfType(arg.type),
    ]),
  )

export class GqlGenerator {
  constructor(
    private inputVars: RagVars,
    private flowName: string,
    private gqlSchema: GraphQLSchema,
    private depthLimit = 100,
    private includeDeprecatedFields = false,
  ) {}

  /**
   * Generate a selection for the specified field
   *
   * @param fieldName name of a field on a GraphQL type
   * @param parentTypeName name of the parent GraphQL type
   * @param parentFieldName name of the parent field
   * @param argumentsDict dictionary of arguments from all fields
   * @param duplicateArgCounts map for deduping argument name collisions
   * @param crossReferenceKeyList list of the cross reference
   * @param curDepth current depth of field
   * @param fromUnion adds additional depth for unions to avoid empty child
   */
  generateFieldSelection({
    fieldName,
    parentTypeName,
    parentFieldName,
    argumentsDict = {},
    duplicateArgCounts = {},
    crossReferenceKeyList = [], // [`${parentFieldName}To${fieldName}Key`]
    curDepth = 1,
    fromUnion = false,
  }: {
    fieldName: string
    parentTypeName: string
    parentFieldName?: string
    argumentsDict?: Record<string, GraphQLArgument>
    duplicateArgCounts?: Record<string, number>
    crossReferenceKeyList?: string[]
    curDepth?: number
    fromUnion?: boolean
  }): {
    selection: string
    argumentsDict: Record<string, GraphQLArgument>
  } {
    const parentType = this.gqlSchema.getType(parentTypeName)
    if (
      !parentType ||
      !(isObjectType(parentType) || isInterfaceType(parentType))
    ) {
      console.log(
        '[gqlg warning]:',
        `the parent type name ${parentTypeName} does not refer to an object or interface type`,
      )
      return {selection: '', argumentsDict}
    }

    const field = parentType.getFields()[fieldName]
    if (!field) {
      console.log(
        '[gqlg warning]:',
        `the field name ${fieldName} does not exist on the ${parentType} type`,
      )
      return {selection: '', argumentsDict}
    }

    const fieldTypeName = field.type.toJSON().replace(/[[\]!]/g, '')
    const fieldType = this.gqlSchema.getType(fieldTypeName)
    if (!fieldType) {
      console.log(
        '[gqlg warning]:',
        `cannot resolve the type ${fieldTypeName} of the ${parentTypeName}.${fieldName} field`,
      )
      return {selection: '', argumentsDict}
    }

    let childSelection = ''
    if (isScalarType(fieldType) || isEnumType(fieldType)) {
      // no-op - no child selection set
    } else if (isObjectType(fieldType) || isInterfaceType(fieldType)) {
      const crossReferenceKey = `${parentFieldName}To${fieldName}Key`
      if (
        crossReferenceKeyList.indexOf(crossReferenceKey) !== -1 ||
        (fromUnion ? curDepth - 2 : curDepth) > this.depthLimit
      ) {
        return {selection: '', argumentsDict}
      }
      if (!fromUnion) {
        crossReferenceKeyList.push(crossReferenceKey)
      }
      childSelection = Object.keys(fieldType.getFields())
        .filter(childFieldName => {
          /* Exclude deprecated fields */
          const childField = fieldType.getFields()[childFieldName]
          return this.includeDeprecatedFields || !childField.deprecationReason
        })
        .map(
          childFieldName =>
            this.generateFieldSelection({
              fieldName: childFieldName,
              parentTypeName: `${fieldType}`,
              parentFieldName: fieldName,
              argumentsDict,
              duplicateArgCounts,
              crossReferenceKeyList,
              curDepth: curDepth + 1,
              fromUnion,
            }).selection,
        )
        .filter(selection => Boolean(selection))
        .join('\n')
    } else if (isUnionType(fieldType)) {
      const memberTypes = fieldType.getTypes()
      if (memberTypes.length) {
        const indent = `${'    '.repeat(curDepth)}`
        const fragIndent = `${'    '.repeat(curDepth + 1)}`
        childSelection = `${fragIndent}__typename\n`

        const unionMemberSelections = memberTypes
          .map(unionType => {
            const unionMemberSelection = Object.keys(unionType.getFields())
              .map(
                unionTypeFieldName =>
                  this.generateFieldSelection({
                    fieldName: unionTypeFieldName,
                    parentTypeName: unionType.name,
                    parentFieldName: fieldName,
                    argumentsDict,
                    duplicateArgCounts,
                    crossReferenceKeyList,
                    curDepth: curDepth + 2,
                    fromUnion: true,
                  }).selection,
              )
              .filter(selectionSet => Boolean(selectionSet))
              .join('\n')

            /* Exclude empty unions */
            return unionMemberSelection
              ? `${fragIndent}... on ${unionType} {\n${unionMemberSelection}\n${fragIndent}}`
              : ''
          })
          .filter(selectionSet => Boolean(selectionSet))
          .join('\n')

        if (unionMemberSelections) {
          childSelection += `${unionMemberSelections}\n`
        }

        childSelection += `${indent}`
      }
    } else {
      console.log(
        '[gqlg warning]:',
        `the kind ${fieldType.astNode?.kind} of the ${fieldTypeName} type is not supported`,
      )
      return {selection: '', argumentsDict}
    }

    let selection = `${'    '.repeat(curDepth)}${fieldName}`

    function findMatchingObjects(arr: readonly GraphQLArgument[], obj: {}) {
      const keys = Object.keys(obj)
      return arr.filter(item => keys.includes(item.name))
    }

    if (field.args.length > 0) {
      field.args = findMatchingObjects(field.args, this.inputVars)
      const dict = getFieldArgsDict(field, duplicateArgCounts, argumentsDict)
      Object.assign(argumentsDict, dict)
      selection += `(${getArgsToVarsStr(dict)})`
    }

    if (childSelection) {
      selection += `{${childSelection}}\n`
    }

    selection += `${'    '.repeat(curDepth)}`

    return {selection, argumentsDict}
  }

  generateSampleOperation(): {
    query?: string
    vars?: Record<string, any>
    error?: string
  } {
    type candidateArray = Array<{
      field: GraphQLField<any, any>
      parentTypeName: string
      operationType: 'subscription' | 'query' | 'mutation'
    }>
    const candidates: candidateArray = []

    const subscriptionType = this.gqlSchema.getSubscriptionType()
    if (subscriptionType) {
      const fields = subscriptionType.getFields()
      candidates.push(
        ...Object.keys(fields).map(fieldName => ({
          field: fields[fieldName],
          parentTypeName: subscriptionType.name,
          operationType: 'subscription' as const,
        })),
      )
    }

    const queryType = this.gqlSchema.getQueryType()
    if (queryType) {
      const fields = queryType.getFields()
      candidates.push(
        ...Object.keys(fields).map(fieldName => ({
          field: fields[fieldName],
          parentTypeName: queryType.name,
          operationType: 'query' as const,
        })),
      )
    }

    const mutationType = this.gqlSchema.getMutationType()
    if (mutationType) {
      const fields = mutationType.getFields()
      candidates.push(
        ...Object.keys(fields).map(fieldName => ({
          field: fields[fieldName],
          parentTypeName: mutationType.name,
          operationType: 'mutation' as const,
        })),
      )
    }

    type MatchingCandidate = {
      field: GraphQLField<any, any, any>
      argumentsDict: Record<string, GraphQLArgument>
      operationType: 'subscription' | 'query' | 'mutation'
      selection: string
    }

    const createQuery = ({
      field,
      parentTypeName,
      operationType,
    }: {
      field: GraphQLField<any, any>
      parentTypeName: string
      operationType: 'subscription' | 'query' | 'mutation'
    }): MatchingCandidate => {
      const queryResult = this.generateFieldSelection({
        fieldName: field.name,
        parentTypeName,
      })

      const acc = {
        field,
        argumentsDict: queryResult.argumentsDict,
        operationType,
        selection: queryResult.selection,
      }

      return acc
    }

    const buildQuery = ({candidates}: {candidates: candidateArray}) => {
      for (const field of candidates) {
        const candidate = field.field.name
        if (candidate === this.flowName) {
          const queryObj = createQuery(field)
          const varsToTypesStr = getVarsToTypesStr(queryObj.argumentsDict)
          const selectionSet = queryObj.selection
          const query = `${queryObj.operationType} ${queryObj.field.name}${
            varsToTypesStr ? `(${varsToTypesStr})` : ''
          }{\n${selectionSet}\n}`

          return {
            query: print(parse(query)),
            vars: getSampleVars(queryObj.argumentsDict),
          }
        }
      }
      return {
        error: `Error: cannot find flowName '${this.flowName}' in the schema.`,
      }
    }

    return buildQuery({candidates})
  }
}

export const generateSampleOperation = ({
  inputVars,
  flowName,
  schema,
  depthLimit = 100,
  includeDeprecatedFields = false,
}: {
  inputVars: RagVars
  flowName: string
  schema: GraphQLSchema
  depthLimit?: number
  includeDeprecatedFields?: boolean
}): {
  query?: string
  variables?: Record<string, any>
  error?: string
} => {
  return new GqlGenerator(
    inputVars,
    flowName,
    schema,
    depthLimit,
    includeDeprecatedFields,
  ).generateSampleOperation()
}

export const generateFields = ({schema}: {schema: GraphQLSchema}): string[] => {
  type candidateArray = Array<{
    field: GraphQLField<any, any>
    parentTypeName: string
    operationType: 'subscription' | 'query' | 'mutation'
  }>
  const candidates: candidateArray = []

  const subscriptionType = schema.getSubscriptionType()
  if (subscriptionType) {
    const fields = subscriptionType.getFields()
    candidates.push(
      ...Object.keys(fields).map(fieldName => ({
        field: fields[fieldName],
        parentTypeName: subscriptionType.name,
        operationType: 'subscription' as const,
      })),
    )
  }

  const queryType = schema.getQueryType()
  if (queryType) {
    const fields = queryType.getFields()
    candidates.push(
      ...Object.keys(fields).map(fieldName => ({
        field: fields[fieldName],
        parentTypeName: queryType.name,
        operationType: 'query' as const,
      })),
    )
  }

  const mutationType = schema.getMutationType()
  if (mutationType) {
    const fields = mutationType.getFields()
    candidates.push(
      ...Object.keys(fields).map(fieldName => ({
        field: fields[fieldName],
        parentTypeName: mutationType.name,
        operationType: 'mutation' as const,
      })),
    )
  }

  const buildQuery = ({candidates}: {candidates: candidateArray}) => {
    let fields: string[] = []
    for (const field of candidates) {
      fields.push(field.field.name)
    }
    return fields
  }

  return buildQuery({candidates})
}
