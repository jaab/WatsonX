"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright IBM Corp. 2023, 2024
const flow_1 = require("./flow");
const getFields_1 = require("./getFields");
const generate_1 = require("./generate");
const rag_1 = require("./rag");
const lodash_1 = __importDefault(require("lodash"));
class wxflows {
    constructor({ endpoint, apikey, flowName, vars }) {
        this.flow = async ({ flowName, question, }) => {
            if (flowName) {
                try {
                    const response = await (0, flow_1.fetchFlow)(this.endpoint, flowName, question, this.apikey);
                    return response;
                }
                catch (error) {
                    return error;
                }
            }
            else {
                throw new Error('No flow name provided. Please provide one in your request.');
            }
        };
        this.generate = async () => {
            const response = await (0, generate_1.generateSchema)(this.endpoint, this.apikey);
            if (response?.error?.message) {
                return response?.error?.message;
            }
            else {
                return JSON.stringify(response);
            }
        };
        this.getFields = ({ schema }) => {
            const response = (0, getFields_1.findFields)(schema);
            return JSON.stringify(response);
        };
        this.ragAnswer = async ({ schema, flowName, variables, query, }) => {
            const ragVars = this.vars?.rag
                ? lodash_1.default.merge(variables, this.vars?.rag)
                : variables;
            const flow = flowName || this.flowName;
            const inputQuery = query;
            // TO-DO: Write it with !query... if query provided, no need to fetch schema
            if (!schema) {
                // TO-DO: Notify auto-generation in response
                const response = await (0, generate_1.generateSchema)(this.endpoint, this.apikey);
                if (response?.error?.message) {
                    return response?.error?.message;
                }
                else {
                    schema = JSON.stringify(response);
                }
            }
            if (flow) {
                const response = await (0, rag_1.fetchRag)(this.endpoint, flow, schema, this.apikey, ragVars, inputQuery);
                return response;
            }
            else {
                return 'Please provide the flowName to wxflows or property ragAnswer';
            }
        };
        this.endpoint = endpoint;
        this.apikey = apikey;
        this.flowName = flowName;
        this.vars = vars;
    }
    async call(prompt) {
        if (this.vars) {
            const result = await this.ragAnswer({
                flowName: this.flowName,
                variables: this.vars.rag,
            });
            return result;
        }
    }
    pipe() {
        // This method should return a new instance of the model
        return new wxflows(this);
    }
    async invoke(prompt) {
        // Use the model to generate a response
        const response = await this.call(prompt);
        return response;
    }
}
exports.default = wxflows;
//# sourceMappingURL=wxflows.js.map