"use strict";
// Copyright IBM Corp. 2024
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSampleOperation = exports.GqlGenerator = exports.getSampleVars = exports.getSampleValueOfType = exports.getVarsToTypesStr = exports.getArgsToVarsStr = exports.getFieldArgsDict = void 0;
const graphql_1 = require("graphql");
/**
 * Compile arguments dictionary for a field
 * @param field current field object
 * @param duplicateArgCounts map for deduping argument name collisions
 * @param allArgsDict dictionary of all arguments
 */
const getFieldArgsDict = (field, duplicateArgCounts, allArgsDict = {}) => field.args.reduce((o, arg) => {
    if (arg.name in duplicateArgCounts) {
        const index = duplicateArgCounts[arg.name] + 1;
        duplicateArgCounts[arg.name] = index;
        o[`${arg.name}${index}`] = arg;
    }
    else if (allArgsDict[arg.name]) {
        duplicateArgCounts[arg.name] = 1;
        o[`${arg.name}1`] = arg;
    }
    else {
        o[arg.name] = arg;
    }
    return o;
}, {});
exports.getFieldArgsDict = getFieldArgsDict;
/**
 * Generate variables string
 * @param dict dictionary of arguments
 */
const getArgsToVarsStr = (dict) => Object.entries(dict)
    .map(([varName, arg]) => `${arg.name}: $${varName}`)
    .join(', ');
exports.getArgsToVarsStr = getArgsToVarsStr;
/**
 * Generate types string
 * @param dict dictionary of arguments
 */
const getVarsToTypesStr = (dict) => Object.entries(dict)
    .map(([varName, arg]) => `$${varName}: ${arg.type}`)
    .join(', ');
exports.getVarsToTypesStr = getVarsToTypesStr;
/**
 * Generate a example value for a given a GraphQL type
 * @param type GraphQL type
 */
const getSampleValueOfType = (type) => {
    if ((0, graphql_1.isNullableType)(type)) {
        return null;
    }
    const nullableType = (0, graphql_1.getNullableType)(type);
    if ((0, graphql_1.isScalarType)(nullableType)) {
        const argType = nullableType.toString();
        switch (argType) {
            case 'Boolean':
                return true;
            case 'Float':
                return 1.5;
            case 'Int':
                return 1;
            case 'Date':
            case 'DateTime':
            case 'Time':
                return new Date().toISOString();
            case 'JSON':
                return { foo: 'bar' };
            case 'Secret':
                return 'secret';
            case 'ID':
                return 'id';
            case 'String':
            default:
                return 'string';
        }
    }
    if ((0, graphql_1.isEnumType)(nullableType)) {
        const enumValues = nullableType.getValues();
        return enumValues.length ? enumValues[0].value : null;
    }
    if ((0, graphql_1.isObjectType)(nullableType) ||
        (0, graphql_1.isInterfaceType)(nullableType) ||
        (0, graphql_1.isInputObjectType)(nullableType)) {
        const fields = nullableType.getFields();
        return Object.fromEntries(Object.keys(fields)
            .map(fieldName => [
            fieldName,
            (0, exports.getSampleValueOfType)(fields[fieldName].type),
        ])
            .filter(([_, value]) => value !== null));
    }
    if ((0, graphql_1.isListType)(nullableType)) {
        const sampleListItem = (0, exports.getSampleValueOfType)(nullableType.ofType);
        return [sampleListItem, sampleListItem];
    }
};
exports.getSampleValueOfType = getSampleValueOfType;
const getSampleVars = (dict) => Object.fromEntries(Object.entries(dict).map(([varName, arg]) => [
    varName,
    arg.defaultValue || (0, exports.getSampleValueOfType)(arg.type),
]));
exports.getSampleVars = getSampleVars;
class GqlGenerator {
    constructor(inputVars, flowName, gqlSchema, depthLimit = 100, includeDeprecatedFields = false) {
        this.inputVars = inputVars;
        this.flowName = flowName;
        this.gqlSchema = gqlSchema;
        this.depthLimit = depthLimit;
        this.includeDeprecatedFields = includeDeprecatedFields;
    }
    /**
     * Generate a selection for the specified field
     *
     * @param fieldName name of a field on a GraphQL type
     * @param parentTypeName name of the parent GraphQL type
     * @param parentFieldName name of the parent field
     * @param argumentsDict dictionary of arguments from all fields
     * @param duplicateArgCounts map for deduping argument name collisions
     * @param crossReferenceKeyList list of the cross reference
     * @param curDepth current depth of field
     * @param fromUnion adds additional depth for unions to avoid empty child
     */
    generateFieldSelection({ fieldName, parentTypeName, parentFieldName, argumentsDict = {}, duplicateArgCounts = {}, crossReferenceKeyList = [], // [`${parentFieldName}To${fieldName}Key`]
    curDepth = 1, fromUnion = false, }) {
        const parentType = this.gqlSchema.getType(parentTypeName);
        if (!parentType ||
            !((0, graphql_1.isObjectType)(parentType) || (0, graphql_1.isInterfaceType)(parentType))) {
            console.log('[gqlg warning]:', `the parent type name ${parentTypeName} does not refer to an object or interface type`);
            return { selection: '', argumentsDict };
        }
        const field = parentType.getFields()[fieldName];
        if (!field) {
            console.log('[gqlg warning]:', `the field name ${fieldName} does not exist on the ${parentType} type`);
            return { selection: '', argumentsDict };
        }
        const fieldTypeName = field.type.toJSON().replace(/[[\]!]/g, '');
        const fieldType = this.gqlSchema.getType(fieldTypeName);
        if (!fieldType) {
            console.log('[gqlg warning]:', `cannot resolve the type ${fieldTypeName} of the ${parentTypeName}.${fieldName} field`);
            return { selection: '', argumentsDict };
        }
        let childSelection = '';
        if ((0, graphql_1.isScalarType)(fieldType) || (0, graphql_1.isEnumType)(fieldType)) {
            // no-op - no child selection set
        }
        else if ((0, graphql_1.isObjectType)(fieldType) || (0, graphql_1.isInterfaceType)(fieldType)) {
            const crossReferenceKey = `${parentFieldName}To${fieldName}Key`;
            if (crossReferenceKeyList.indexOf(crossReferenceKey) !== -1 ||
                (fromUnion ? curDepth - 2 : curDepth) > this.depthLimit) {
                return { selection: '', argumentsDict };
            }
            if (!fromUnion) {
                crossReferenceKeyList.push(crossReferenceKey);
            }
            childSelection = Object.keys(fieldType.getFields())
                .filter(childFieldName => {
                /* Exclude deprecated fields */
                const childField = fieldType.getFields()[childFieldName];
                return this.includeDeprecatedFields || !childField.deprecationReason;
            })
                .map(childFieldName => this.generateFieldSelection({
                fieldName: childFieldName,
                parentTypeName: `${fieldType}`,
                parentFieldName: fieldName,
                argumentsDict,
                duplicateArgCounts,
                crossReferenceKeyList,
                curDepth: curDepth + 1,
                fromUnion,
            }).selection)
                .filter(selection => Boolean(selection))
                .join('\n');
        }
        else if ((0, graphql_1.isUnionType)(fieldType)) {
            const memberTypes = fieldType.getTypes();
            if (memberTypes.length) {
                const indent = `${'    '.repeat(curDepth)}`;
                const fragIndent = `${'    '.repeat(curDepth + 1)}`;
                childSelection = `${fragIndent}__typename\n`;
                const unionMemberSelections = memberTypes
                    .map(unionType => {
                    const unionMemberSelection = Object.keys(unionType.getFields())
                        .map(unionTypeFieldName => this.generateFieldSelection({
                        fieldName: unionTypeFieldName,
                        parentTypeName: unionType.name,
                        parentFieldName: fieldName,
                        argumentsDict,
                        duplicateArgCounts,
                        crossReferenceKeyList,
                        curDepth: curDepth + 2,
                        fromUnion: true,
                    }).selection)
                        .filter(selectionSet => Boolean(selectionSet))
                        .join('\n');
                    /* Exclude empty unions */
                    return unionMemberSelection
                        ? `${fragIndent}... on ${unionType} {\n${unionMemberSelection}\n${fragIndent}}`
                        : '';
                })
                    .filter(selectionSet => Boolean(selectionSet))
                    .join('\n');
                if (unionMemberSelections) {
                    childSelection += `${unionMemberSelections}\n`;
                }
                childSelection += `${indent}`;
            }
        }
        else {
            console.log('[gqlg warning]:', `the kind ${fieldType.astNode?.kind} of the ${fieldTypeName} type is not supported`);
            return { selection: '', argumentsDict };
        }
        let selection = `${'    '.repeat(curDepth)}${fieldName}`;
        function findMatchingObjects(arr, obj) {
            const keys = Object.keys(obj);
            return arr.filter(item => keys.includes(item.name));
        }
        if (field.args.length > 0) {
            field.args = findMatchingObjects(field.args, this.inputVars);
            const dict = (0, exports.getFieldArgsDict)(field, duplicateArgCounts, argumentsDict);
            Object.assign(argumentsDict, dict);
            selection += `(${(0, exports.getArgsToVarsStr)(dict)})`;
        }
        if (childSelection) {
            selection += `{${childSelection}}\n`;
        }
        selection += `${'    '.repeat(curDepth)}`;
        return { selection, argumentsDict };
    }
    generateSampleOperation() {
        const candidates = [];
        const subscriptionType = this.gqlSchema.getSubscriptionType();
        if (subscriptionType) {
            const fields = subscriptionType.getFields();
            candidates.push(...Object.keys(fields).map(fieldName => ({
                field: fields[fieldName],
                parentTypeName: subscriptionType.name,
                operationType: 'subscription',
            })));
        }
        const queryType = this.gqlSchema.getQueryType();
        if (queryType) {
            const fields = queryType.getFields();
            candidates.push(...Object.keys(fields).map(fieldName => ({
                field: fields[fieldName],
                parentTypeName: queryType.name,
                operationType: 'query',
            })));
        }
        const mutationType = this.gqlSchema.getMutationType();
        if (mutationType) {
            const fields = mutationType.getFields();
            candidates.push(...Object.keys(fields).map(fieldName => ({
                field: fields[fieldName],
                parentTypeName: mutationType.name,
                operationType: 'mutation',
            })));
        }
        const createQuery = ({ field, parentTypeName, operationType, }) => {
            const queryResult = this.generateFieldSelection({
                fieldName: field.name,
                parentTypeName,
            });
            const acc = {
                field,
                argumentsDict: queryResult.argumentsDict,
                operationType,
                selection: queryResult.selection,
            };
            return acc;
        };
        const buildQuery = ({ candidates }) => {
            for (const field of candidates) {
                const candidate = field.field.name;
                if (candidate === this.flowName) {
                    const queryObj = createQuery(field);
                    const varsToTypesStr = (0, exports.getVarsToTypesStr)(queryObj.argumentsDict);
                    const selectionSet = queryObj.selection;
                    const query = `${queryObj.operationType} ${queryObj.field.name}${varsToTypesStr ? `(${varsToTypesStr})` : ''}{\n${selectionSet}\n}`;
                    return {
                        query: (0, graphql_1.print)((0, graphql_1.parse)(query)),
                        vars: (0, exports.getSampleVars)(queryObj.argumentsDict),
                    };
                }
            }
            return {
                error: `Error: cannot find flowName '${this.flowName}' in the schema.`,
            };
        };
        return buildQuery({ candidates });
    }
}
exports.GqlGenerator = GqlGenerator;
const generateSampleOperation = ({ inputVars, flowName, schema, depthLimit = 100, includeDeprecatedFields = false, }) => {
    return new GqlGenerator(inputVars, flowName, schema, depthLimit, includeDeprecatedFields).generateSampleOperation();
};
exports.generateSampleOperation = generateSampleOperation;
//# sourceMappingURL=graphiql-helpers.js.map