/**
 * A utility type for cases when you prefer to explicitly return an error
 * value from a function rather than throwing an exception.
 *
 * The optional `error?: never` property is a trick to make the TS compiler
 * accept both `{ result: ... }` and `{ error: ... }` as valid return values.
 *
 * The default error type is `{message: string}` rather than a plain `string`
 * to allow the TS compiler to infer the `result` type from `if (error)`
 * checks. When `error` is an object it may be falsy only when undefined (which
 * implies `result` is defined). When `error` is a string, it may be falsy
 * even if it has a value (if it's an empty string). This means a simple
 * `if (!error)` condition is not sufficient to assume `result` is defined.
 *
 * Intended usage (on the caller side):
 * ```
 * const {result, error} = foo()
 * if (error) {
 *   // error is defined here
 * } else {
 *   // result is defined here
 * }
 * ```
 */
export type ErrorOr<T, E = {message: string}> =
  | {result: T; error?: never}
  | {error: E; result?: never}
