// Copyright IBM Corp. 2023, 2024
import {fetchFlow} from './flow'
import {findFields} from './getFields'
import {generateSchema} from './generate'
import {RagVars, fetchRag} from './rag'
import _ from 'lodash'

interface WatZenProps {
  endpoint: string
  apikey?: string
  flowName?: string
}

type PromptProps = {
  lc_serializable: true
  lc_kwargs: {value: string}
  lc_namespace: [string]
  value: string
}

class WatZen {
  endpoint: string
  apikey?: string
  flowName?: string
  vars?: {
    rag?: RagVars
  }

  constructor({endpoint, apikey, flowName}: WatZenProps) {
    this.endpoint = endpoint
    this.apikey = apikey
    this.flowName = flowName
  }

  flow = async ({
    flowName,
    question,
  }: {
    flowName?: string
    question: string
  }) => {
    if (flowName) {
      try {
        const response = await fetchFlow(
          this.endpoint,
          flowName,
          question,
          this.apikey,
        )
        return response
      } catch (error) {
        return error
      }
    } else {
      throw new Error(
        'No flow name provided. Please provide one in your request.',
      )
    }
  }

  generate = async () => {
    const response = await generateSchema(this.endpoint, this.apikey)
    if (response?.error?.message) {
      return response?.error?.message
    } else {
      return JSON.stringify(response)
    }
  }

  getFields = ({schema}: {schema: string}) => {
    const response = findFields(schema)

    return JSON.stringify(response)
  }

  ragAnswer = async ({
    schema,
    flowName,
    variables,
    query,
  }: {
    schema: string
    flowName?: string
    variables?: RagVars
    query?: string
  }) => {
    const ragVars = this.vars?.rag
      ? _.merge(variables, this.vars?.rag)
      : variables

    const flow = flowName || (this.flowName as string)
    const inputQuery = query

    if (flow) {
      const response = await fetchRag(
        this.endpoint,
        flow,
        schema,
        this.apikey,
        ragVars,
        inputQuery,
      )
      return response
    } else {
      return 'Please provide the flowName to WatZen or property ragAnswer'
    }
  }

  async call(prompt: PromptProps) {
    const result = await this.flow({
      flowName: this.flowName,
      question: prompt.value,
    })

    return result
  }

  pipe() {
    // This method should return a new instance of the model
    return new WatZen(this)
  }

  async invoke(prompt: PromptProps) {
    // Use the model to generate a response
    const response = await this.call(prompt)
    return response
  }
}

export default WatZen
